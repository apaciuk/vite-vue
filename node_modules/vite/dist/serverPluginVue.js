"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const resolveVue_1 = require("./resolveVue");
const hash_sum_1 = __importDefault(require("hash-sum"));
const utils_1 = require("./utils");
const lru_cache_1 = __importDefault(require("lru-cache"));
const serverPluginHmr_1 = require("./serverPluginHmr");
const resolve_from_1 = __importDefault(require("resolve-from"));
const debug = require('debug')('vite:sfc');
exports.vueCache = new lru_cache_1.default({
    max: 65535
});
exports.vuePlugin = ({ root, app }) => {
    app.use(async (ctx, next) => {
        if (!ctx.path.endsWith('.vue')) {
            return next();
        }
        const pathname = ctx.path;
        const query = ctx.query;
        const filename = path_1.default.join(root, pathname.slice(1));
        const descriptor = await parseSFC(root, filename);
        if (!descriptor) {
            debug(`${ctx.url} - 404`);
            ctx.status = 404;
            return;
        }
        if (!query.type) {
            ctx.type = 'js';
            ctx.body = compileSFCMain(descriptor, filename, pathname, query.t);
            return;
        }
        if (query.type === 'template') {
            ctx.type = 'js';
            ctx.body = compileSFCTemplate(root, descriptor.template, filename, pathname, descriptor.styles.some((s) => s.scoped));
            return;
        }
        if (query.type === 'style') {
            const index = Number(query.index);
            const styleBlock = descriptor.styles[index];
            const result = await compileSFCStyle(root, styleBlock, index, filename, pathname);
            if (query.module != null) {
                ctx.type = 'js';
                ctx.body = `export default ${JSON.stringify(result.modules)}`;
            }
            else {
                ctx.type = 'css';
                ctx.body = result.code;
            }
            return;
        }
        // TODO custom blocks
    });
};
async function parseSFC(root, filename) {
    let cached = exports.vueCache.get(filename);
    if (cached && cached.descriptor) {
        return cached.descriptor;
    }
    let content;
    try {
        content = await utils_1.cachedRead(filename, 'utf-8');
    }
    catch (e) {
        return;
    }
    const { descriptor, errors } = resolveVue_1.resolveCompiler(root).parse(content, {
        filename
    });
    if (errors) {
        // TODO
    }
    cached = cached || { styles: [] };
    cached.descriptor = descriptor;
    exports.vueCache.set(filename, cached);
    return descriptor;
}
exports.parseSFC = parseSFC;
function compileSFCMain(descriptor, filename, pathname, timestamp) {
    let cached = exports.vueCache.get(filename);
    if (cached && cached.script) {
        return cached.script;
    }
    timestamp = timestamp ? `&t=${timestamp}` : ``;
    // inject hmr client
    let code = `import { updateStyle } from "${serverPluginHmr_1.hmrClientPublicPath}"\n`;
    if (descriptor.script) {
        code += descriptor.script.content.replace(`export default`, 'const __script =');
    }
    else {
        code += `const __script = {}`;
    }
    const id = hash_sum_1.default(pathname);
    let hasScoped = false;
    let hasCSSModules = false;
    if (descriptor.styles) {
        descriptor.styles.forEach((s, i) => {
            const styleRequest = pathname + `?type=style&index=${i}${timestamp}`;
            if (s.scoped)
                hasScoped = true;
            if (s.module) {
                if (!hasCSSModules) {
                    code += `\nconst __cssModules = __script.__cssModules = {}`;
                    hasCSSModules = true;
                }
                const styleVar = `__style${i}`;
                const moduleName = typeof s.module === 'string' ? s.module : '$style';
                code += `\nimport ${styleVar} from ${JSON.stringify(styleRequest + '&module')}`;
                code += `\n__cssModules[${JSON.stringify(moduleName)}] = ${styleVar}`;
            }
            code += `\nupdateStyle("${id}-${i}", ${JSON.stringify(styleRequest)})`;
        });
        if (hasScoped) {
            code += `\n__script.__scopeId = "data-v-${id}"`;
        }
    }
    if (descriptor.template) {
        code += `\nimport { render as __render } from ${JSON.stringify(pathname + `?type=template${timestamp}`)}`;
        code += `\n__script.render = __render`;
    }
    code += `\n__script.__hmrId = ${JSON.stringify(pathname)}`;
    code += `\n__script.__file = ${JSON.stringify(filename)}`;
    code += `\nexport default __script`;
    cached = cached || { styles: [] };
    cached.script = code;
    exports.vueCache.set(filename, cached);
    return code;
}
function compileSFCTemplate(root, template, filename, pathname, scoped) {
    let cached = exports.vueCache.get(filename);
    if (cached && cached.template) {
        return cached.template;
    }
    const { code, errors } = resolveVue_1.resolveCompiler(root).compileTemplate({
        source: template.content,
        filename,
        compilerOptions: {
            scopeId: scoped ? `data-v-${hash_sum_1.default(pathname)}` : null,
            runtimeModuleName: '/@modules/vue'
        }
    });
    if (errors) {
        // TODO
    }
    cached = cached || { styles: [] };
    cached.template = code;
    exports.vueCache.set(filename, cached);
    return code;
}
async function compileSFCStyle(root, style, index, filename, pathname) {
    let cached = exports.vueCache.get(filename);
    if (cached && cached.styles && cached.styles[index]) {
        return cached.styles[index];
    }
    const id = hash_sum_1.default(pathname);
    const result = await resolveVue_1.resolveCompiler(root).compileStyleAsync({
        source: style.content,
        filename,
        id: `data-v-${id}`,
        scoped: style.scoped != null,
        modules: style.module != null,
        preprocessLang: style.lang,
        preprocessCustomRequire: (id) => require(resolve_from_1.default(root, id))
        // TODO load postcss config if present
    });
    if (result.errors) {
        // TODO
    }
    cached = cached || { styles: [] };
    cached.styles[index] = result;
    exports.vueCache.set(filename, cached);
    return result;
}
