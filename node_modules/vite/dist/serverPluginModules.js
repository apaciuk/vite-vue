"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const resolveVue_1 = require("./resolveVue");
const path_1 = __importDefault(require("path"));
const resolve_from_1 = __importDefault(require("resolve-from"));
const stream_1 = require("stream");
const es_module_lexer_1 = require("es-module-lexer");
const magic_string_1 = __importDefault(require("magic-string"));
const utils_1 = require("./utils");
const fs_1 = require("fs");
const serverPluginHmr_1 = require("./serverPluginHmr");
const parser_1 = require("@babel/parser");
const lru_cache_1 = __importDefault(require("lru-cache"));
const chalk_1 = __importDefault(require("chalk"));
const debugImportRewrite = require('debug')('vite:rewrite');
const debugModuleResolution = require('debug')('vite:resolve');
const idToFileMap = new Map();
const fileToIdMap = new Map();
const webModulesMap = new Map();
const rewriteCache = new lru_cache_1.default({ max: 65535 });
exports.modulesPlugin = ({ root, app, watcher }) => {
    // bust module rewrite cache on file change
    watcher.on('change', (file) => {
        const servedPath = '/' + path_1.default.relative(root, file);
        debugImportRewrite(`${servedPath}: cache busted`);
        rewriteCache.del(servedPath);
    });
    // rewrite named module imports to `/@modules/:id` requests
    app.use(async (ctx, next) => {
        await next();
        if (ctx.status === 304) {
            return;
        }
        if (ctx.url === '/index.html') {
            if (rewriteCache.has('/index.html')) {
                debugImportRewrite('/index.html: serving from cache');
                ctx.body = rewriteCache.get('/index.html');
            }
            else {
                const html = await readBody(ctx.body);
                await es_module_lexer_1.init;
                ctx.body = html.replace(/(<script\b[^>]*>)([\s\S]*?)<\/script>/gm, (_, openTag, script) => {
                    return `${openTag}${rewriteImports(script, '/index.html')}</script>`;
                });
                rewriteCache.set('/index.html', ctx.body);
            }
        }
        // we are doing the js rewrite after all other middlewares have finished;
        // this allows us to post-process javascript produced by user middlewares
        // regardless of the extension of the original files.
        if (ctx.response.is('js') &&
            !ctx.url.endsWith('.map') &&
            // skip internal client
            !ctx.path.startsWith(`/@hmr`) &&
            // only need to rewrite for <script> part in vue files
            !(ctx.path.endsWith('.vue') && ctx.query.type != null)) {
            if (rewriteCache.has(ctx.path)) {
                debugImportRewrite(`${ctx.path}: serving from cache`);
                ctx.body = rewriteCache.get(ctx.path);
            }
            else {
                await es_module_lexer_1.init;
                ctx.body = rewriteImports(await readBody(ctx.body), ctx.url.replace(/(&|\?)t=\d+/, ''), ctx.query.t);
                rewriteCache.set(ctx.path, ctx.body);
            }
        }
    });
    // handle /@modules/:id requests
    const moduleRE = /^\/@modules\//;
    const getDebugPath = (p) => {
        const relative = path_1.default.relative(root, p);
        return relative.startsWith('..') ? p : relative;
    };
    app.use(async (ctx, next) => {
        if (!moduleRE.test(ctx.path)) {
            return next();
        }
        const id = ctx.path.replace(moduleRE, '');
        ctx.type = 'js';
        // special handling for vue's runtime.
        if (id === 'vue') {
            const vuePath = resolveVue_1.resolveVue(root).vue;
            ctx.body = await utils_1.cachedRead(vuePath);
            debugModuleResolution(`vue -> ${getDebugPath(vuePath)}`);
            return;
        }
        // already resolved and cached
        const cachedPath = idToFileMap.get(id);
        if (cachedPath) {
            debugModuleResolution(`(cached) ${id} -> ${getDebugPath(cachedPath)}`);
            ctx.body = await utils_1.cachedRead(cachedPath);
            return;
        }
        // source map request
        if (id.endsWith('.map')) {
            // try to reverse-infer the original file that made the sourcemap request.
            // assumes the `.js` and `.js.map` files to have the same prefix.
            const sourceMapRequest = id;
            const jsRequest = sourceMapRequest.replace(/\.map$/, '');
            const moduleId = fileToIdMap.get(path_1.default.basename(jsRequest));
            if (!moduleId) {
                console.error(chalk_1.default.red(`[vite] failed to infer original js file for source map request: ` +
                    sourceMapRequest));
                ctx.status = 404;
                return;
            }
            else {
                const modulePath = idToFileMap.get(moduleId);
                const sourceMapPath = path_1.default.join(path_1.default.dirname(modulePath), path_1.default.basename(sourceMapRequest));
                idToFileMap.set(sourceMapRequest, sourceMapPath);
                ctx.type = 'application/json';
                ctx.body = await utils_1.cachedRead(sourceMapPath);
                debugModuleResolution(`(source map) ${id} -> ${getDebugPath(sourceMapPath)}`);
                return;
            }
        }
        try {
            const webModulePath = await resolveWebModule(root, id);
            if (webModulePath) {
                idToFileMap.set(id, webModulePath);
                fileToIdMap.set(path_1.default.basename(webModulePath), id);
                ctx.body = await utils_1.cachedRead(webModulePath);
                debugModuleResolution(`${id} -> ${getDebugPath(webModulePath)}`);
                return;
            }
        }
        catch (e) {
            console.error(chalk_1.default.red(`[vite] Error while resolving web_modules with id "${id}":`));
            console.error(e);
            ctx.status = 404;
        }
        // resolve from node_modules
        try {
            // get the module name in case of deep imports like 'foo/dist/bar.js'
            let moduleName = id;
            const deepIndex = id.indexOf('/');
            if (deepIndex > 0) {
                moduleName = id.slice(0, deepIndex);
            }
            const pkgPath = resolve_from_1.default(root, `${moduleName}/package.json`);
            const pkg = require(pkgPath);
            const moduleRelativePath = deepIndex > 0
                ? id.slice(deepIndex + 1)
                : pkg.module || pkg.main || 'index.js';
            const modulePath = path_1.default.join(path_1.default.dirname(pkgPath), moduleRelativePath);
            idToFileMap.set(id, modulePath);
            fileToIdMap.set(path_1.default.basename(modulePath), id);
            debugModuleResolution(`${id} -> ${getDebugPath(modulePath)}`);
            ctx.body = await utils_1.cachedRead(modulePath);
        }
        catch (e) {
            console.error(chalk_1.default.red(`[vite] Error while resolving node_modules with id "${id}":`));
            console.error(e);
            ctx.status = 404;
        }
    });
};
async function readBody(stream) {
    if (stream instanceof stream_1.Readable) {
        return new Promise((resolve, reject) => {
            let res = '';
            stream
                .on('data', (chunk) => (res += chunk))
                .on('error', reject)
                .on('end', () => {
                resolve(res);
            });
        });
    }
    else {
        return stream;
    }
}
async function resolveWebModule(root, id) {
    const webModulePath = webModulesMap.get(id);
    if (webModulePath) {
        return webModulePath;
    }
    const importMapPath = path_1.default.join(root, 'web_modules', 'import-map.json');
    if (await fs_1.promises.stat(importMapPath).catch((e) => false)) {
        const importMap = require(importMapPath);
        if (importMap.imports) {
            const webModulesDir = path_1.default.dirname(importMapPath);
            Object.entries(importMap.imports).forEach(([key, val]) => webModulesMap.set(key, path_1.default.join(webModulesDir, val)));
            return webModulesMap.get(id);
        }
    }
}
exports.importerMap = new Map();
exports.importeeMap = new Map();
exports.hmrBoundariesMap = new Map();
const ensureMapEntry = (map, key) => {
    let entry = map.get(key);
    if (!entry) {
        entry = new Set();
        map.set(key, entry);
    }
    return entry;
};
function rewriteImports(source, importer, timestamp) {
    if (typeof source !== 'string') {
        source = String(source);
    }
    try {
        const [imports] = es_module_lexer_1.parse(source);
        if (imports.length) {
            debugImportRewrite(`${importer}: rewriting`);
            const s = new magic_string_1.default(source);
            let hasReplaced = false;
            const prevImportees = exports.importeeMap.get(importer);
            const currentImportees = new Set();
            exports.importeeMap.set(importer, currentImportees);
            imports.forEach(({ s: start, e: end, d: dynamicIndex }) => {
                const id = source.substring(start, end);
                if (dynamicIndex === -1) {
                    if (/^[^\/\.]/.test(id)) {
                        const rewritten = `/@modules/${id}`;
                        s.overwrite(start, end, rewritten);
                        hasReplaced = true;
                        debugImportRewrite(`    "${id}" --> "${rewritten}"`);
                    }
                    else if (id === serverPluginHmr_1.hmrClientPublicPath) {
                        if (!/.vue$|.vue\?type=/.test(importer)) {
                            // the user explicit imports the HMR API in a js file
                            // making the module hot.
                            parseAcceptedDeps(source, importer, s);
                            // we rewrite the hot.accept call
                            hasReplaced = true;
                        }
                    }
                    else {
                        // force re-fetch all imports by appending timestamp
                        // if this is a hmr refresh request
                        if (timestamp) {
                            debugImportRewrite(`    appending hmr timestamp to "${id}"`);
                            s.overwrite(start, end, `${id}${/\?/.test(id) ? `&` : `?`}t=${timestamp}`);
                            hasReplaced = true;
                        }
                        // save the import chain for hmr analysis
                        const importee = path_1.default.join(path_1.default.dirname(importer), id);
                        currentImportees.add(importee);
                        ensureMapEntry(exports.importerMap, importee).add(importer);
                    }
                }
                else if (dynamicIndex >= 0) {
                    // TODO dynamic import
                }
            });
            // since the importees may have changed due to edits,
            // check if we need to remove this importer from certain importees
            if (prevImportees) {
                prevImportees.forEach((importee) => {
                    if (!currentImportees.has(importee)) {
                        const importers = exports.importerMap.get(importee);
                        if (importers) {
                            importers.delete(importer);
                        }
                    }
                });
            }
            if (!hasReplaced) {
                debugImportRewrite(`    no imports rewritten.`);
            }
            return hasReplaced ? s.toString() : source;
        }
        else {
            debugImportRewrite(`${importer}: no imports found.`);
        }
        return source;
    }
    catch (e) {
        console.error(`[vite] Error: module imports rewrite failed for ${importer}.\n`, e);
        debugImportRewrite(source);
        return source;
    }
}
function parseAcceptedDeps(source, importer, s) {
    const ast = parser_1.parse(source, {
        sourceType: 'module',
        plugins: [
            // by default we enable proposals slated for ES2020.
            // full list at https://babeljs.io/docs/en/next/babel-parser#plugins
            // this should be kept in async with @vue/compiler-core's support range
            'bigInt',
            'optionalChaining',
            'nullishCoalescingOperator'
        ]
    }).program.body;
    const registerDep = (e) => {
        const deps = ensureMapEntry(exports.hmrBoundariesMap, importer);
        const depPublicPath = path_1.default.join(path_1.default.dirname(importer), e.value);
        deps.add(depPublicPath);
        s.overwrite(e.start, e.end, JSON.stringify(depPublicPath));
    };
    ast.forEach((node) => {
        if (node.type === 'ExpressionStatement' &&
            node.expression.type === 'CallExpression' &&
            node.expression.callee.type === 'MemberExpression' &&
            node.expression.callee.object.type === 'Identifier' &&
            node.expression.callee.object.name === 'hot' &&
            node.expression.callee.property.name === 'accept') {
            const args = node.expression.arguments;
            // inject the imports's own path so it becomes
            // hot.accept('/foo.js', ['./bar.js'], () => {})
            s.appendLeft(args[0].start, JSON.stringify(importer) + ', ');
            // register the accepted deps
            if (args[0].type === 'ArrayExpression') {
                args[0].elements.forEach((e) => {
                    if (e && e.type !== 'StringLiteral') {
                        console.error(`[vite] HMR syntax error in ${importer}: hot.accept() deps list can only contain string literals.`);
                    }
                    else if (e) {
                        registerDep(e);
                    }
                });
            }
            else if (args[0].type === 'StringLiteral') {
                registerDep(args[0]);
            }
            else {
                console.error(`[vite] HMR syntax error in ${importer}: hot.accept() expects a dep string or an array of deps.`);
            }
        }
    });
}
